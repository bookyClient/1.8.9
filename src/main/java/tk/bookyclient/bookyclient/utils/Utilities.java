package tk.bookyclient.bookyclient.utils;

import net.minecraftforge.fml.common.ModMetadata;

import javax.crypto.KeyGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class Utilities {

    private long blurStart = 0L, tick;

    Utilities() {
    }

    @SafeVarargs
    public final <K, V> Map<K, V> createMap(Pair<K, V>... pairs) {
        Map<K, V> map = new HashMap<>();
        for (Pair<K, V> pair : pairs) map.put(pair.getKey(), pair.getValue());
        return map;
    }

    public ModMetadata fillMetadata(ModMetadata metadata) {
        metadata.autogenerated = false;

        metadata.modId = Constants.MOD_ID;
        metadata.name = Constants.MOD_NAME;
        metadata.version = Constants.VERSION;

        metadata.description = "This is a minecraft client.";
        metadata.authorList = Collections.singletonList(Constants.AUTHOR);

        metadata.updateJSON = "https://" + Constants.MOD_ID + ".tk/update.json";
        metadata.logoFile = "assets/" + Constants.MOD_ID + "/logo.png";
        metadata.url = "https://" + Constants.MOD_ID + ".tk/";

        return metadata;
    }

    public MessageDigest getSHA512Hasher() {
        try {
            return MessageDigest.getInstance("SHA-512");
        } catch (NoSuchAlgorithmException exception) {
            throw new Error(exception);
        }
    }

    public KeyGenerator getAESGenerator() {
        try {
            return KeyGenerator.getInstance("AES");
        } catch (NoSuchAlgorithmException exception) {
            throw new Error(exception);
        }
    }

    public int getGUIBackgroundColor() {
        int color = 75000000;
        float progress = getBlurProgress();

        int a = (int) ((color >>> 24) * progress);
        int r = (int) (((color >> 16) & 0xFF) * progress);
        int b = (int) (((color >> 8) & 0xFF) * progress);
        int g = (int) ((color & 0xFF) * progress);

        return a << 24 | r << 16 | b << 8 | g;
    }

    public float getBlurProgress() {
        return Math.min((System.currentTimeMillis() - blurStart) / (float) 100, 1);
    }

    public void setBlurStart() {
        blurStart = System.currentTimeMillis();
    }

    public long getTick() {
        return tick;
    }

    public void tick() {
        tick = System.nanoTime();
    }

    public float easeScroll(float[] target, float scroll, float maxScroll, float delta, double start, double duration) {
        target[0] = clamp(target[0], maxScroll);

        if (target[0] < 0) {
            target[0] -= target[0] * (1 - 0.24f) * delta / 3;
        } else if (target[0] > maxScroll) {
            target[0] = (target[0] - maxScroll) * (1 - (1 - 0.24f) * delta / 3) + maxScroll;
        }

        if (Math.abs(scroll - target[0]) > 1e-3f) {
            return scroll + (target[0] - scroll) * (float) Math.min((System.currentTimeMillis() - start) / duration * delta * 3, 1);
        } else {
            return target[0];
        }
    }

    public float clamp(float value, float maxScroll) {
        return clamp(value, maxScroll, 300);
    }

    public float clamp(float value, float maxScroll, float clampExtension) {
        maxScroll += clampExtension;
        clampExtension = -clampExtension;
        return value < clampExtension ? clampExtension : (Math.min(value, maxScroll));
    }
}
